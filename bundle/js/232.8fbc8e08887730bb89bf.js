/*! For license information please see 232.8fbc8e08887730bb89bf.js.LICENSE.txt */
(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[232],{50839:(e,o,i)=>{"use strict";var r;i.d(o,{d:()=>r}),function(e){e.PanoTexture="PANO_TEXTURE",e.PanoTextureTransition="PANO_TEXTURE_TRANSITION",e.MeshTexture="MESH_TEXTURE",e.ColorOverlay="COLOR_OVERLAY",e.MeshPreviewSphere="MESH_PREVIEW_SPHERE",e.Wireframe="WIREFRAME",e.FlatShading="FLAT_SHADING",e.PanoOverlay="PANO_OVERLAY",e.PanoOverlayTransition="PANO_OVERLAY_TRANSITION",e.MeshTrimVertex="MESH_TRIM_VERTEX",e.MeshTrimPixel="MESH_TRIM_PIXEL",e.FloorTrimVertex="FLOOR_TRIM_VERTEX",e.FloorTrimPixel="FLOOR_TRIM_PIXEL"}(r||(r={}))},2593:(e,o,i)=>{"use strict";i.d(o,{Ay:()=>S,HN:()=>D,fu:()=>N});var r=i(68909),n=i(50839),t=i(39232),a=i.n(t),l=i(18406),c=i.n(l),s=i(9209),d=i.n(s),f=i(4075),v=i.n(f),u=i(28775),m=i.n(u),p=i(59681),y=i.n(p),h=i(71372),x=i.n(h),g=i(17842),E=i.n(g),T=i(21366),P=i.n(T),_=i(90076),R=i.n(_),O=i(1097),M=i.n(O),b=i(27739),L=i.n(b);const D=10,N={uniforms:{[n.d.MeshTexture]:{map:{value:null},meshOpacity:{value:0},opacity:{value:1}},[n.d.MeshTrimVertex]:{meshTrimMatrices:{value:[]},meshTrimsDiscardContents:{value:new Array(D).fill(!0)},hasKeepVolume:{value:!1}},[n.d.MeshTrimPixel]:{meshTrimMatrices:{value:[]},meshTrimsDiscardContents:{value:new Array(D).fill(!0)},hasKeepVolume:{value:!1}},[n.d.FloorTrimVertex]:{floorHeightMin:{value:0},floorHeightMax:{value:1},floorTrimHeight:{value:1}},[n.d.FloorTrimPixel]:{floorHeightMin:{value:0},floorHeightMax:{value:1},floorTrimHeight:{value:1}},[n.d.PanoTexture]:{pano0Map:{value:null},pano0Position:{value:new r.Vector3},pano0Matrix1:{value:new r.Matrix4},pano0Matrix2:{value:new r.Matrix4},panoOpacity:{value:1}},[n.d.PanoTextureTransition]:{progress:{value:0},pano1Map:{value:null},pano1Position:{value:new r.Vector3},pano1Matrix1:{value:new r.Matrix4},pano1Matrix2:{value:new r.Matrix4}},[n.d.PanoOverlay]:{overlay0Map:{value:null},overlay0Matrix:{value:new r.Matrix4}},[n.d.PanoOverlayTransition]:{overlay1Map:{value:null},overlay1Matrix:{value:new r.Matrix4}},[n.d.ColorOverlay]:{colorOverlay:{value:null}},[n.d.MeshPreviewSphere]:{meshPreviewCenter:{value:null},meshPreviewSize:{value:.3}},[n.d.Wireframe]:{time:{value:0},fill:{value:new r.Color(1,0,0)},stroke:{value:new r.Color(1,1,1)},dualStroke:{value:!1},fillEnabled:{value:!1},insideAltColor:{value:!1},thickness:{value:.1},secondThickness:{value:.1},dashEnabled:{value:!1},dashRepeats:{value:10},dashOverlap:{value:!1},dashLength:{value:.1,range:[0,1]},dashAnimate:{value:!1},squeeze:{value:!1},squeezeMin:{value:.1},squeezeMax:{value:1},wireframeOpacity:{value:1,range:[0,1]}}},vertexShader:m(),fragmentShader:y()},S={cube:{uniforms:{map:{value:null},opacity:{value:1}},vertexShader:a(),fragmentShader:c()},blurCube:{uniforms:{map:{value:null},opacity:{value:1},dir:{value:new r.Vector2(0,0)}},vertexShader:d(),fragmentShader:v()},modelOutside:{uniforms:{map:{value:null},opacity:{value:1},colorOverlay:{value:new r.Vector4(0,0,0,0)}},vertexShader:x(),fragmentShader:E()},depth:{uniforms:{opacity:{value:1},maxDistance:{value:20}},vertexShader:P(),fragmentShader:R()},ceilingProcess:{uniforms:{},vertexShader:M(),fragmentShader:L()}}},65936:(e,o,i)=>{"use strict";i.d(o,{m:()=>n});var r=i(55141);class n extends r.u{constructor(e,o,i){super();const r=function*(){return o()}();this.payload={type:e,func:r,maxDelay:i,steps:1}}}n.id="SCHEDULE_TASK_COMMAND"},4075:e=>{e.exports="precision highp float;precision highp int;vec3 closestPointToRay(vec3 point,vec3 origin,vec3 direction){vec3 d=point-origin;float D=dot(d,direction);return origin+D*direction;}vec3 rayIntersectsSphere(vec3 origin,float radius,vec3 rayOrigin,vec3 rayDirection){vec3 chordPoint=closestPointToRay(origin,rayOrigin,rayDirection);float D1=length(rayOrigin-chordPoint);float D=length(chordPoint-origin);float D2=sqrt(radius*radius-D*D);return rayOrigin+(D1+D2)*rayDirection;}uniform samplerCube map;uniform vec2 dir;varying vec3 vWorldPosition;vec3 sphereToUnit(float x,float y){return vec3(sin(x)*cos(y),cos(x),sin(x)*sin(y));}vec2 unitToSphere(vec3 unit){return vec2(atan(sqrt(pow(unit.x,2.)+pow(unit.z,2.)),unit.y),atan(unit.z,unit.x));}void main(){vec2 coord=unitToSphere(vWorldPosition);vec4 sum=textureCube(map,sphereToUnit(coord.x-12.*dir.x,coord.y-12.*dir.y))*KERNEL_1;sum+=textureCube(map,sphereToUnit(coord.x-11.*dir.x,coord.y-11.*dir.y))*KERNEL_2;sum+=textureCube(map,sphereToUnit(coord.x-10.*dir.x,coord.y-10.*dir.y))*KERNEL_3;sum+=textureCube(map,sphereToUnit(coord.x-9.*dir.x,coord.y-9.*dir.y))*KERNEL_4;sum+=textureCube(map,sphereToUnit(coord.x-8.*dir.x,coord.y-8.*dir.y))*KERNEL_5;sum+=textureCube(map,sphereToUnit(coord.x-7.*dir.x,coord.y-7.*dir.y))*KERNEL_6;sum+=textureCube(map,sphereToUnit(coord.x-6.*dir.x,coord.y-6.*dir.y))*KERNEL_7;sum+=textureCube(map,sphereToUnit(coord.x-5.*dir.x,coord.y-5.*dir.y))*KERNEL_8;sum+=textureCube(map,sphereToUnit(coord.x-4.*dir.x,coord.y-4.*dir.y))*KERNEL_9;sum+=textureCube(map,sphereToUnit(coord.x-3.*dir.x,coord.y-3.*dir.y))*KERNEL_10;sum+=textureCube(map,sphereToUnit(coord.x-2.*dir.x,coord.y-2.*dir.y))*KERNEL_11;sum+=textureCube(map,sphereToUnit(coord.x-1.*dir.x,coord.y-1.*dir.y))*KERNEL_12;sum+=textureCube(map,sphereToUnit(coord.x,coord.y))*KERNEL_13;sum+=textureCube(map,sphereToUnit(coord.x+1.*dir.x,coord.y+1.*dir.y))*KERNEL_14;sum+=textureCube(map,sphereToUnit(coord.x+2.*dir.x,coord.y+2.*dir.y))*KERNEL_15;sum+=textureCube(map,sphereToUnit(coord.x+3.*dir.x,coord.y+3.*dir.y))*KERNEL_16;sum+=textureCube(map,sphereToUnit(coord.x+4.*dir.x,coord.y+4.*dir.y))*KERNEL_17;sum+=textureCube(map,sphereToUnit(coord.x+5.*dir.x,coord.y+5.*dir.y))*KERNEL_18;sum+=textureCube(map,sphereToUnit(coord.x+6.*dir.x,coord.y+6.*dir.y))*KERNEL_19;sum+=textureCube(map,sphereToUnit(coord.x+7.*dir.x,coord.y+7.*dir.y))*KERNEL_20;sum+=textureCube(map,sphereToUnit(coord.x+8.*dir.x,coord.y+8.*dir.y))*KERNEL_21;sum+=textureCube(map,sphereToUnit(coord.x+9.*dir.x,coord.y+9.*dir.y))*KERNEL_22;sum+=textureCube(map,sphereToUnit(coord.x+10.*dir.x,coord.y+10.*dir.y))*KERNEL_23;sum+=textureCube(map,sphereToUnit(coord.x+11.*dir.x,coord.y+11.*dir.y))*KERNEL_24;sum+=textureCube(map,sphereToUnit(coord.x+12.*dir.x,coord.y+12.*dir.y))*KERNEL_25;gl_FragColor=linearToOutputTexel(sum);}"},9209:e=>{e.exports="precision highp float;precision highp int;varying vec3 vWorldPosition;void main(){vWorldPosition=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}"},27739:e=>{e.exports="#define SMALL  0.0001\nprecision highp float;precision highp int;layout(location=0)out vec4 gWorldPos;layout(location=1)out vec4 gTiltYaw;in vec3 vNormal;in vec3 vWorldPos;vec3 toVisionCoord(vec3 v){return vec3(v.x,-v.z,v.y);}void main(){vec3 visionNormal=toVisionCoord(normalize(vNormal));vec3 visionWorld=toVisionCoord(vWorldPos);float tilt=0.;float yaw=0.;\n#ifdef FLOOR_SAMPLE\ntilt=acos(visionNormal.z);yaw=0.;\n#endif\n#ifdef CEILING_SAMPLE\ntilt=acos(-visionNormal.z);float yawValid=float(tilt>SMALL);yaw=yawValid*atan(visionNormal.y,visionNormal.x);\n#endif\ngWorldPos=vec4(visionWorld,1.);gTiltYaw=vec4(tilt,yaw,1.,1.);}"},1097:e=>{e.exports="precision highp float;precision highp int;in vec3 position;in vec3 normal;out vec3 vNormal;out vec3 vWorldPos;uniform mat4 modelViewMatrix;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;uniform float opacity;void main(){vNormal=normal;vWorldPos=(modelMatrix*vec4(position,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);if(opacity<1.){gl_Position=vec4(-999.,-999.,-999.,-999.);}}"},18406:e=>{e.exports="precision highp float;precision highp int;vec3 closestPointToRay(vec3 point,vec3 origin,vec3 direction){vec3 d=point-origin;float D=dot(d,direction);return origin+D*direction;}vec3 rayIntersectsSphere(vec3 origin,float radius,vec3 rayOrigin,vec3 rayDirection){vec3 chordPoint=closestPointToRay(origin,rayOrigin,rayDirection);float D1=length(rayOrigin-chordPoint);float D=length(chordPoint-origin);float D2=sqrt(radius*radius-D*D);return rayOrigin+(D1+D2)*rayDirection;}uniform samplerCube map;uniform float opacity;varying vec3 vWorldPosition;void main(){vec4 color=textureCube(map,vec3(-vWorldPosition.x,vWorldPosition.yz));gl_FragColor=linearToOutputTexel(vec4(color.rgb,opacity));}"},39232:e=>{e.exports="precision highp float;precision highp int;varying vec3 vWorldPosition;void main(){vWorldPosition=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}"},90076:e=>{e.exports="precision highp float;precision highp int;vec3 closestPointToRay(vec3 point,vec3 origin,vec3 direction){vec3 d=point-origin;float D=dot(d,direction);return origin+D*direction;}vec3 rayIntersectsSphere(vec3 origin,float radius,vec3 rayOrigin,vec3 rayDirection){vec3 chordPoint=closestPointToRay(origin,rayOrigin,rayDirection);float D1=length(rayOrigin-chordPoint);float D=length(chordPoint-origin);float D2=sqrt(radius*radius-D*D);return rayOrigin+(D1+D2)*rayDirection;}uniform vec3 color;uniform float opacity;uniform float maxDistance;varying vec3 vWorldPosition;void main(){float distanceToCamera=distance(cameraPosition,vWorldPosition);float distanceBucketed=1.-clamp(distanceToCamera/maxDistance,0.,1.);if(opacity<1.){discard;}gl_FragColor=vec4(distanceBucketed,distanceBucketed,distanceBucketed,1.);}"},21366:e=>{e.exports="precision highp float;precision highp int;varying vec3 vWorldPosition;void main(){vWorldPosition=(modelMatrix*vec4(position,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}"},17842:e=>{e.exports="precision highp float;precision highp int;vec3 closestPointToRay(vec3 point,vec3 origin,vec3 direction){vec3 d=point-origin;float D=dot(d,direction);return origin+D*direction;}vec3 rayIntersectsSphere(vec3 origin,float radius,vec3 rayOrigin,vec3 rayDirection){vec3 chordPoint=closestPointToRay(origin,rayOrigin,rayDirection);float D1=length(rayOrigin-chordPoint);float D=length(chordPoint-origin);float D2=sqrt(radius*radius-D*D);return rayOrigin+(D1+D2)*rayDirection;}uniform sampler2D map;uniform float opacity;uniform vec4 colorOverlay;varying vec2 vUv;vec4 white=vec4(0.8,0.8,0.8,1.);vec4 black=vec4(0.,0.,0.,1.);void main(){vec4 colorFromTexture=texture2D(map,vUv);float whiteness=1.-smoothstep(0.1,0.2,opacity);colorFromTexture=mix(colorFromTexture,vec4(colorOverlay.rgb,1.),colorOverlay.a);colorFromTexture=mix(colorFromTexture,white,whiteness);gl_FragColor=linearToOutputTexel(vec4(colorFromTexture.rgb,opacity));}"},71372:e=>{e.exports="precision highp float;precision highp int;varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}"},59681:e=>{e.exports="precision highp float;precision highp int;vec3 closestPointToRay(vec3 point,vec3 origin,vec3 direction){vec3 d=point-origin;float D=dot(d,direction);return origin+D*direction;}vec3 rayIntersectsSphere(vec3 origin,float radius,vec3 rayOrigin,vec3 rayDirection){vec3 chordPoint=closestPointToRay(origin,rayOrigin,rayDirection);float D1=length(rayOrigin-chordPoint);float D=length(chordPoint-origin);float D2=sqrt(radius*radius-D*D);return rayOrigin+(D1+D2)*rayDirection;}\n#define MAX_TRIMS_PER_FLOOR  10\n#ifdef PANO_TEXTURE\nuniform vec3 pano0Position;uniform samplerCube pano0Map;varying vec3 pano0SweepDirection;uniform float panoOpacity;\n#endif\n#ifdef PANO_TEXTURE_TRANSITION\nuniform float progress;uniform vec3 pano1Position;uniform samplerCube pano1Map;varying vec3 pano1SweepDirection;\n#endif\n#ifdef PANO_OVERLAY\nuniform samplerCube overlay0Map;varying vec3 overlay0WorldPos;\n#endif\n#ifdef PANO_OVERLAY_TRANSITION\nuniform samplerCube overlay1Map;varying vec3 overlay1WorldPos;\n#endif\n#ifdef MESH_PREVIEW_SPHERE\nuniform vec3 meshPreviewCenter;uniform float meshPreviewSize;\n#endif\n#ifdef MESH_TEXTURE\nvarying vec2 vUv;uniform sampler2D map;uniform float meshOpacity;uniform float opacity;varying vec3 worldPos;\n#ifdef MESH_TRIM_VERTEX\nvarying vec3 trimPos[MAX_TRIMS_PER_FLOOR];uniform bool meshTrimsDiscardContents[MAX_TRIMS_PER_FLOOR];uniform bool hasKeepVolume;\n#endif\n#ifdef MESH_TRIM_PIXEL\nuniform mat4 meshTrimMatrices[MAX_TRIMS_PER_FLOOR];uniform bool meshTrimsDiscardContents[MAX_TRIMS_PER_FLOOR];uniform bool hasKeepVolume;\n#endif\n#ifdef FLOOR_TRIM_VERTEX\nvarying float floorHeightPercent;\n#endif\n#ifdef FLOOR_TRIM_PIXEL\nuniform float floorTrimHeight;\n#endif\n#endif\n#ifdef COLOR_OVERLAY\nuniform vec4 colorOverlay;\n#endif\n#ifdef WIREFRAME\nvarying vec3 vBarycentric;uniform float time;uniform float thickness;uniform float secondThickness;uniform float dashRepeats;uniform float dashLength;uniform bool dashOverlap;uniform bool dashEnabled;uniform bool dashAnimate;uniform bool fillEnabled;uniform bool insideAltColor;uniform bool dualStroke;uniform bool squeeze;uniform float squeezeMin;uniform float squeezeMax;uniform float wireframeOpacity;uniform vec3 stroke;uniform vec3 fill;float aastep(float threshold,float dist){float afwidth=fwidth(dist)*0.5;return smoothstep(threshold-afwidth,threshold+afwidth,dist);}float computeScreenSpaceWireframe(vec3 barycentric,float lineWidth){vec3 dist=fwidth(barycentric);vec3 smoothed=smoothstep(dist*((lineWidth*0.5)-0.5),dist*((lineWidth*0.5)+0.5),barycentric);return 1.-min(min(smoothed.x,smoothed.y),smoothed.z);}vec4 getStyledWireframe(vec3 barycentric){float PI=3.14159265359;float d=min(min(barycentric.x,barycentric.y),barycentric.z);float positionAlong=max(barycentric.x,barycentric.y);if(barycentric.y<barycentric.x&&barycentric.y<barycentric.z){positionAlong=1.-positionAlong;}float computedThickness=thickness;if(squeeze){computedThickness*=mix(squeezeMin,squeezeMax,(1.-sin(positionAlong*PI)));}if(dashEnabled){float offset=1./dashRepeats*dashLength/2.;if(!dashOverlap){offset+=1./dashRepeats/2.;}if(dashAnimate){offset+=time*0.22;}float pattern=fract((positionAlong+offset)*dashRepeats);computedThickness*=1.-aastep(dashLength,pattern);}float edge=computeScreenSpaceWireframe(barycentric,computedThickness);vec4 outColor=vec4(0.,0.,0.,0.);if(!fillEnabled){outColor=vec4(stroke,edge);if(insideAltColor&&!gl_FrontFacing){outColor.rgb=fill;}}else{outColor.a=1.;if(dualStroke){float inner=1.-aastep(secondThickness,d);vec3 wireColor=mix(fill,stroke,abs(inner-edge));outColor.rgb=wireColor;}else{outColor.rgb=mix(fill,stroke,edge);}}outColor.a*=wireframeOpacity;return outColor;}\n#endif\n#ifdef FLAT_SHADING\nvarying vec3 vNormal;\n#endif\nvoid main(){\n#ifdef PANO_TEXTURE_TRANSITION\nvec4 colorFromPano0=textureCube(pano0Map,pano0SweepDirection.xyz);vec4 colorFromPano1=textureCube(pano1Map,pano1SweepDirection.xyz);\n#ifdef PANO_OVERLAY_TRANSITION\nvec4 colorFromOverlay0=textureCube(overlay0Map,overlay0WorldPos.xyz);vec4 colorFromOverlay1=textureCube(overlay1Map,overlay1WorldPos.xyz);colorFromPano0.rgb=mix(colorFromPano0.rgb,colorFromOverlay0.rgb,colorFromOverlay0.a);colorFromPano1.rgb=mix(colorFromPano1.rgb,colorFromOverlay1.rgb,colorFromOverlay1.a);\n#endif\nvec4 color=mix(colorFromPano0,colorFromPano1,progress);color.a=panoOpacity;\n#elif defined(PANO_TEXTURE)\nvec4 color=textureCube(pano0Map,pano0SweepDirection.xyz);\n#ifdef PANO_OVERLAY\nvec4 colorFromOverlay0=textureCube(overlay0Map,overlay0WorldPos.xyz);color.rgb=mix(color.rgb,colorFromOverlay0.rgb,colorFromOverlay0.a);\n#endif\ncolor.a=panoOpacity;\n#else\nvec4 color=vec4(0.,0.,0.,0.);\n#endif\n#ifdef MESH_TEXTURE\nvec4 colorFromTexture=texture2D(map,vUv);\n#endif\n#ifdef MESH_PREVIEW_SPHERE\nfloat previewDistance=distance(worldPos.xyz,meshPreviewCenter.xyz);float inSphere=step(previewDistance,meshPreviewSize);colorFromTexture+=colorFromTexture*(0.2*inSphere);color=mix(color,colorFromTexture,max(meshOpacity,inSphere));\n#elif defined(MESH_TEXTURE)\ncolor=mix(color,colorFromTexture,meshOpacity);\n#endif\n#ifdef FLAT_SHADING\nfloat ao=0.9-abs(vNormal.y)*0.3-abs(vNormal.x)*0.1+abs(vNormal.z)*0.05;color.rgb=color.rgb*vec3(ao,ao*1.025,ao*1.05);\n#endif\n#ifdef COLOR_OVERLAY\ncolor=mix(color,vec4(colorOverlay.rgb,1.),colorOverlay.a);\n#endif\n#ifdef WIREFRAME\nvec4 colorFromWireframe=getStyledWireframe(vBarycentric);color=mix(color,vec4(colorFromWireframe.rgb,1.),colorFromWireframe.a);\n#endif\n#ifdef MESH_TEXTURE\ncolor.a=opacity;\n#if defined(FLOOR_TRIM_VERTEX) || defined(FLOOR_TRIM_PIXEL)\nif(floorHeightPercent>floorTrimHeight){discard;}\n#endif\n#if defined(MESH_TRIM_VERTEX) || defined(MESH_TRIM_PIXEL)\nbool isWithinVolume=false;bool doKeepFragment=true;bool enabled=true;vec4 worldPos4=vec4(worldPos.xyz,1);vec3 compare=vec3(0.5);\n#pragma unroll_loop_start\nfor(int i=0;i<10;i++){\n#ifdef MESH_TRIM_VERTEX\nenabled=!all(equal(trimPos[UNROLLED_LOOP_INDEX],vec3(0.)));if(enabled){if(all(lessThan(abs(trimPos[UNROLLED_LOOP_INDEX]),compare))){isWithinVolume=true;if(meshTrimsDiscardContents[UNROLLED_LOOP_INDEX]){doKeepFragment=false;}}}\n#endif\n#ifdef MESH_TRIM_PIXEL\nenabled=meshTrimMatrices[UNROLLED_LOOP_INDEX][3][3]>0.;if(enabled){if(all(lessThan(abs((meshTrimMatrices[UNROLLED_LOOP_INDEX]*worldPos4).xyz),compare))){isWithinVolume=true;if(meshTrimsDiscardContents[UNROLLED_LOOP_INDEX]){doKeepFragment=false;}}}\n#endif\n}\n#pragma unroll_loop_end\nif(!isWithinVolume&&hasKeepVolume){discard;}else if(isWithinVolume&&!doKeepFragment){discard;}\n#endif\n#endif\nif(color.a<0.01){discard;}gl_FragColor=linearToOutputTexel(color);}"},28775:e=>{e.exports="precision highp float;precision highp int;\n#define MAX_TRIMS_PER_FLOOR  10\n#ifdef PANO_TEXTURE\nuniform vec3 pano0Position;uniform mat4 pano0Matrix1;uniform mat4 pano0Matrix2;varying vec3 pano0SweepDirection;\n#endif\n#ifdef PANO_TEXTURE_TRANSITION\nuniform vec3 pano1Position;uniform mat4 pano1Matrix1;uniform mat4 pano1Matrix2;varying vec3 pano1SweepDirection;\n#endif\n#ifdef PANO_OVERLAY\nvarying vec3 overlay0WorldPos;uniform mat4 overlay0Matrix;\n#endif\n#ifdef PANO_OVERLAY_TRANSITION\nvarying vec3 overlay1WorldPos;uniform mat4 overlay1Matrix;\n#endif\n#ifdef MESH_PREVIEW_SPHERE\n#endif\n#ifdef MESH_TEXTURE\nvarying vec2 vUv;varying vec3 worldPos;\n#ifdef MESH_TRIM_VERTEX\nuniform mat4 meshTrimMatrices[MAX_TRIMS_PER_FLOOR];varying vec3 trimPos[MAX_TRIMS_PER_FLOOR];\n#endif\n#ifdef FLOOR_TRIM_VERTEX\nuniform float floorHeightMin;uniform float floorHeightMax;varying float floorHeightPercent;\n#endif\n#endif\n#ifdef WIREFRAME\nattribute vec3 barycentric;varying vec3 vBarycentric;\n#endif\n#ifdef FLAT_SHADING\nvarying vec3 vNormal;\n#endif\nvoid main(){vec4 worldPosition=modelMatrix*vec4(position,1.);\n#ifdef MESH_TEXTURE\nvUv=uv;worldPos=worldPosition.xyz;\n#ifdef MESH_TRIM_VERTEX\n#pragma unroll_loop_start\nfor(int i=0;i<10;i++){trimPos[UNROLLED_LOOP_INDEX]=(meshTrimMatrices[UNROLLED_LOOP_INDEX]*vec4(worldPos,1.)).xyz;}\n#pragma unroll_loop_end\n#endif\n#ifdef FLOOR_TRIM_VERTEX\nfloorHeightPercent=(worldPos.y-floorHeightMin)/(floorHeightMax-floorHeightMin);\n#endif\n#endif\n#ifdef WIREFRAME\nvBarycentric=barycentric;\n#endif\n#ifdef FLAT_SHADING\nvNormal=normal;\n#endif\n#ifdef PANO_TEXTURE\nvec3 positionLocalToPanoCenter0=worldPosition.xyz-pano0Position;pano0SweepDirection=(pano0Matrix2*pano0Matrix1*vec4(positionLocalToPanoCenter0,1.)).xyz;\n#ifdef PANO_OVERLAY\noverlay0WorldPos=(overlay0Matrix*vec4(positionLocalToPanoCenter0,1.)).xyz;\n#endif\n#endif\n#ifdef PANO_TEXTURE_TRANSITION\nvec3 positionLocalToPanoCenter1=worldPosition.xyz-pano1Position;pano1SweepDirection=(pano1Matrix2*pano1Matrix1*vec4(positionLocalToPanoCenter1,1.)).xyz;\n#ifdef PANO_OVERLAY_TRANSITION\noverlay1WorldPos=(overlay1Matrix*vec4(positionLocalToPanoCenter1,1.)).xyz;\n#endif\n#endif\nvec4 projectedPosition=projectionMatrix*modelViewMatrix*vec4(position,1.);gl_Position=projectedPosition;}"}}]);